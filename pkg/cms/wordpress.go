package cms

import (
	"fmt"
	"svp/pkg/database"
	"svp/pkg/utils"
	"path/filepath"
	"strings"
)

// InstallWordPress installs a WordPress site for a domain
func InstallWordPress(domain, webroot, gitRepo, gitBranch string, sitesDir string) error {
	utils.Section("Installing WordPress for " + domain)

	// Get admin username from www-data group
	adminUser := "admin"
	output, err := utils.RunShell("getent group www-data | cut -d: -f4")
	if err == nil {
		members := strings.Split(strings.TrimSpace(output), ",")
		for _, member := range members {
			if member != "" && member != "www-data" {
				adminUser = member
				break
			}
		}
	}

	domainDir := filepath.Join(webroot, domain)

	// Check if directory exists and is not empty
	if utils.CheckDirExists(domainDir) {
		entries, err := utils.RunShell(fmt.Sprintf("ls -A %s | wc -l", domainDir))
		if err == nil && strings.TrimSpace(entries) != "0" {
			utils.Warn("Directory %s is not empty", domainDir)
			fmt.Print("Delete and reprovision? [y/N]: ")
			var response string
			fmt.Scanln(&response)
			if strings.ToLower(response) != "y" {
				return fmt.Errorf("aborted: directory not empty")
			}
			utils.Log("Removing existing directory...")
			if _, err := utils.RunCommand("rm", "-rf", domainDir); err != nil {
				return fmt.Errorf("failed to remove directory: %v", err)
			}
		}
	}

	// Ensure webroot exists
	if err := utils.EnsureDir(domainDir); err != nil {
		return fmt.Errorf("failed to create domain directory: %v", err)
	}

	// Set ownership to admin:www-data
	_, _ = utils.RunCommand("chown", "-R", fmt.Sprintf("%s:www-data", adminUser), domainDir)
	_, _ = utils.RunCommand("chmod", "-R", "775", domainDir)

	// Check if Git repo is specified
	if gitRepo != "" {
		utils.Log("Cloning Git repository: %s (branch: %s)", gitRepo, gitBranch)

		// Clone repository as admin user
		// CD to webroot first to avoid getcwd issues if directory was deleted
		if !utils.CheckDirExists(filepath.Join(domainDir, ".git")) {
			_, err := utils.RunShell(fmt.Sprintf("cd %s && sudo -u %s git clone -b %s %s %s", webroot, adminUser, gitBranch, gitRepo, domainDir))
			if err != nil {
				return fmt.Errorf("failed to clone repository: %v", err)
			}
			utils.Ok("Repository cloned successfully")
		} else {
			utils.Verify("Repository already cloned")
		}
	} else {
		// Fresh WordPress installation using WP-CLI
		utils.Log("Installing WordPress using WP-CLI...")

		// Check if wp-config.php already exists
		wpConfig := filepath.Join(domainDir, "wp-config.php")
		if utils.CheckFileExists(wpConfig) {
			utils.Verify("WordPress already installed")
		} else {
			// Download WordPress core
			utils.Log("Downloading WordPress core...")
			_, err := utils.RunShell(fmt.Sprintf("cd %s && sudo -u %s wp core download", domainDir, adminUser))
			if err != nil {
				return fmt.Errorf("failed to download WordPress: %v", err)
			}
			utils.Ok("WordPress core downloaded")
		}
	}

	// Create database
	dbName, dbUser, dbPass, err := database.CreateDatabase(domain, sitesDir)
	if err != nil {
		return fmt.Errorf("failed to create database: %v", err)
	}

	// Create wp-config.php if it doesn't exist
	wpConfig := filepath.Join(domainDir, "wp-config.php")
	if !utils.CheckFileExists(wpConfig) {
		utils.Log("Creating wp-config.php...")

		// Generate WordPress salts
		salts, err := utils.RunShell("curl -s https://api.wordpress.org/secret-key/1.1/salt/")
		if err != nil {
			salts = generateWordPressSalts()
		}

		wpConfigContent := fmt.Sprintf(`<?php
/**
 * WordPress configuration file
 * Generated by VPS Provisioner
 */

// ** Database settings ** //
define( 'DB_NAME', '%s' );
define( 'DB_USER', '%s' );
define( 'DB_PASSWORD', '%s' );
define( 'DB_HOST', 'localhost' );
define( 'DB_CHARSET', 'utf8mb4' );
define( 'DB_COLLATE', '' );

// ** Authentication Unique Keys and Salts ** //
%s

// ** WordPress Database Table prefix ** //
$table_prefix = 'wp_';

// ** WordPress debugging mode ** //
define( 'WP_DEBUG', false );

// ** Absolute path to the WordPress directory ** //
if ( ! defined( 'ABSPATH' ) ) {
	define( 'ABSPATH', __DIR__ . '/' );
}

// ** Sets up WordPress vars and included files ** //
require_once ABSPATH . 'wp-settings.php';
`, dbName, dbUser, dbPass, salts)

		_, err = utils.RunShell(fmt.Sprintf("cat > %s <<'WPEOF'\n%s\nWPEOF", wpConfig, wpConfigContent))
		if err != nil {
			return fmt.Errorf("failed to write wp-config.php: %v", err)
		}

		utils.Ok("wp-config.php created")
	} else {
		utils.Verify("wp-config.php already exists")
	}

	// Set proper ownership and permissions
	_, _ = utils.RunCommand("chown", "-R", fmt.Sprintf("%s:www-data", adminUser), domainDir)
	_, _ = utils.RunCommand("find", domainDir, "-type", "d", "-exec", "chmod", "775", "{}", "+")
	_, _ = utils.RunCommand("find", domainDir, "-type", "f", "-exec", "chmod", "664", "{}", "+")

	utils.Ok("WordPress installation complete for %s", domain)
	return nil
}

// InstallWPCLI installs WP-CLI globally
func InstallWPCLI(verifyOnly bool) error {
	if utils.CheckFileExists("/usr/local/bin/wp") {
		utils.Verify("WP-CLI already installed")
		return nil
	}

	if verifyOnly {
		utils.Fail("WP-CLI not installed")
		return fmt.Errorf("wp-cli not installed")
	}

	utils.Log("Installing WP-CLI...")

	// Download WP-CLI
	_, err := utils.RunShell("curl -o /tmp/wp-cli.phar https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar")
	if err != nil {
		return fmt.Errorf("failed to download WP-CLI: %v", err)
	}

	// Make executable
	_, err = utils.RunCommand("chmod", "+x", "/tmp/wp-cli.phar")
	if err != nil {
		return fmt.Errorf("failed to make WP-CLI executable: %v", err)
	}

	// Move to bin directory
	_, err = utils.RunCommand("mv", "/tmp/wp-cli.phar", "/usr/local/bin/wp")
	if err != nil {
		return fmt.Errorf("failed to install WP-CLI: %v", err)
	}

	utils.Ok("WP-CLI installed successfully")
	return nil
}

// generateWordPressSalts generates WordPress authentication salts
func generateWordPressSalts() string {
	keys := []string{
		"AUTH_KEY", "SECURE_AUTH_KEY", "LOGGED_IN_KEY", "NONCE_KEY",
		"AUTH_SALT", "SECURE_AUTH_SALT", "LOGGED_IN_SALT", "NONCE_SALT",
	}

	var salts []string
	for _, key := range keys {
		salt, _ := database.GeneratePassword(64)
		salts = append(salts, fmt.Sprintf("define( '%s', '%s' );", key, salt))
	}

	return strings.Join(salts, "\n")
}
